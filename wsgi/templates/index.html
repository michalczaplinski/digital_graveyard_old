<html>
    <head>
        <title>DIGITAL GRAVEYARD</title>
        <style>
            canvas { width: 100%; height: 100% }

            body {margin: 0px;}

            #info {display: none;}
        </style>
    </head>
    <body>

        <div id='info'>
            <p id='length'>{{length}}</p>
            <ul id='tweets'>{% for tweet in tweets %}
                <div id="names_and_users">
                    <p id='name'>{{tweet[0]}}</p>
                    <p id='user'>{{tweet[1]}}</p>
                    <p id='time'>{{tweet[2]}}</p>
                </div>
                 {% endfor %}
            </ul>
        </div>

        <!-- <script src='static/jquery-2.1.1.js' type="text/javascript"></script> -->
        <script src="static/three.js" type="text/javascript"></script>
        <!-- <script src='static/jquery-2.1.1.min.js' type="text/javascript"></script> -->
        <!-- <script src="static/three.min.js" type="text/javascript"></script> -->
        <script src="static/Detector.js" type="text/javascript"></script>
        <script src="static/helvetiker_regular.typeface.js" type="text/javascript"></script>
        <script>


// DETECT INCOMPATIBLE BROWSERS AND DEVICES
    if ( ! Detector.webgl ) {
        Detector.addGetWebGLMessage();
        document.getElementById( 'container' ).innerHTML = ""; }

// CONSTANTS AND VARIABLE DECLARATIONS
    var NUM_ROWS = 11;
    var BACKGROUND_COLOR = 0xffffff;
    var FOG_COLOR = 0xffffff;
    var ul, user, name, time;

// INIT SCENE CAMERA AND RENDERER
    var scene = new THREE.Scene();
    var camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
    var renderer = new THREE.WebGLRenderer({ alpha: true });
    renderer.setClearColor( BACKGROUND_COLOR, 1);
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);


// GET THE INFO FROM THE DOM
    var num_tweets = parseInt(document.getElementById('length').innerHTML);
    var tweetArray = Array( num_tweets );
    for (var i = 0; i < num_tweets; i++) {
        ul = document.getElementById('tweets');
        name = ul.getElementsByTagName('div')[i].childNodes[1].innerHTML;
        user = ul.getElementsByTagName('div')[i].childNodes[3].innerHTML;
        time = ul.getElementsByTagName('div')[i].childNodes[5].innerHTML;
        tweetArray[i] = {name: name, user: user, time: time};
    }


// SET UP THE TERRAIN
    var planeGeometry = new THREE.PlaneGeometry(1000,1000);
    var planeMaterial = new THREE.MeshBasicMaterial({ color:0xbeb5b3} );
    var plane = new THREE.Mesh(planeGeometry, planeMaterial);
    plane.castShadow = false;
    plane.receiveShadow = false;
    scene.add( plane );


// ADD GRAVES AND TEXT

    var POSITION_X, POSITION_Y;

    var parameters = {
        size: .05,
        height: .05,
        font: "helvetiker",
        curveSegments: 4,
        style: 'normal',
        weight: 'normal',
        bevelThickness : .005,
        bevelSize : .005,
        bevelEnabled : true, };

    var geometry = new THREE.BoxGeometry( 1, 1, 3);
    var RIPgeometry = new THREE.TextGeometry( '# R I P', parameters );

    for( var i = 0; i < num_tweets; i++ ){

        POSITION_X = i % NUM_ROWS * 3 - 15;
        POSITION_Y = Math.floor(i/NUM_ROWS) * 7;

        tombstone = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: 0x767575 } ) );
        tombstone.position.x = POSITION_X;
        tombstone.position.y = POSITION_Y;
        tombstone.position.z = 1;
        tombstone.castShadow = false;
        tombstone.receiveShadow = false;

        rip_text = new THREE.Mesh(RIPgeometry, new THREE.MeshLambertMaterial( { color: 0xc90400 } ));
        rip_text.position.x = POSITION_X - .3;
        rip_text.position.y = POSITION_Y - .5;
        rip_text.position.z = 2;
        rip_text.rotation.x = Math.PI / 2;
        tombstone.castShadow = false;
        tombstone.receiveShadow = false;

        var name_geometry = new THREE.TextGeometry(tweetArray[i].name, parameters);
        name_text = new THREE.Mesh(name_geometry, new THREE.MeshLambertMaterial( { color: 0xc90400 } ));
        name_text.position.x = POSITION_X - .3;
        name_text.position.y = POSITION_Y - .5;
        name_text.position.z = 1.9;
        name_text.rotation.x = Math.PI / 2;
        name_text.castShadow = false;
        name_text.receiveShadow = false;

        var user_geometry = new THREE.TextGeometry('@' + tweetArray[i].user, parameters);
        user_text = new THREE.Mesh(user_geometry, new THREE.MeshLambertMaterial( { color: 0xc90400 } ));
        user_text.position.x = POSITION_X - .3;
        user_text.position.y = POSITION_Y - .5;
        user_text.position.z = 1.6;
        user_text.rotation.x = Math.PI / 2;
        user_text.castShadow = false;
        user_text.receiveShadow = false;

        var time_geometry = new THREE.TextGeometry(tweetArray[i].time, parameters);
        time_text = new THREE.Mesh(time_geometry, new THREE.MeshLambertMaterial( { color: 0xc90400 } ));
        time_text.position.x = POSITION_X - .3;
        time_text.position.y = POSITION_Y - .5;
        time_text.position.z = 1.5;
        time_text.rotation.x = Math.PI / 2;
        time_text.castShadow = false;
        time_text.receiveShadow = false;

        scene.add( tombstone );
        scene.add( rip_text );
        scene.add( user_text );
        scene.add( name_text );
        scene.add( time_text);
    }


// SET THE CAMERA POSITION AND DIRECTION
    camera.setLens(60)
    camera.position.x = 0;
    camera.position.y = -10;
    camera.position.z = 1.3 ;
    vec = new THREE.Vector3(0, 25, 1)
    camera.lookAt(vec)
    scene.add( camera );


// LIGHTS
    var light = new THREE.DirectionalLight( 0xffffff, 1 );
    light.position.set(0, -1, .5);
    light.castShadow = true;
    scene.add( light );

// FOG
    scene.fog = new THREE.FogExp2( FOG_COLOR, 0.03 );


// MOVING
    var timer;

    function move () {
        if( moveState.front && !moveState.backwards) {
            camera.position.y += 0.1; }
        if( moveState.left && !moveState.right) {
            camera.position.x -= 0.1; }
        if( !moveState.front && moveState.backwards) {
            camera.position.y -= 0.1; }
        if( !moveState.left && moveState.right) {
            camera.position.x += 0.1; }
    }

    var moveState = {
        moving    : false,
        front     : false,
        backwards : false,
        left      : false,
        right     : false, }

    document.addEventListener('keydown', function(e){
        if( !/65|68|83|87/.test(e.keyCode)){ return }
        if( e.keyCode === 87 ){
            moveState.front     = true;
            moveState.backwards = false;
        } else if ( e.keyCode === 83 ){
            moveState.backwards = true;
            moveState.front     = false;
        } else if ( e.keyCode === 65 ){
            moveState.left  = true;
            moveState.right = false;
        } else if ( e.keyCode === 68 ){
            moveState.right = true;
            moveState.left  = false;
        }
        if(!moveState.moving){
            moveState.moving = true;
            move();
            timer = setInterval( function(){
                move();
            }, 1000 / 60);
        }
    }, false);

    document.addEventListener('keyup', function(e){
        if( !/65|68|83|87/.test(e.keyCode) ) {
            return }
        if( e.keyCode === 87 ){
            moveState.front = false;
        } else if ( e.keyCode === 83 ){
            moveState.backwards = false;
        } else if ( e.keyCode === 65 ){
            moveState.left = false;
        } else if ( e.keyCode === 68 ){
            moveState.right = false;
        }
        if(!moveState.front && !moveState.backwards && !moveState.left && !moveState.right){
            moveState.moving = false;
            clearInterval(timer);
        }
    }, false);


// DEAL WITH WINDOW RESIZING
    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize( window.innerWidth, window.innerHeight );
    }
    window.addEventListener( 'resize', onWindowResize, false );


    function animate(){
        requestAnimationFrame( animate );
        renderer.render(scene, camera);
    }

    animate();

        </script>
    </body>
</html>
