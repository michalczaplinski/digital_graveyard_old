<html>
    <head>
        <title>DIGITAL GRAVEYARD</title>
        <style>
            canvas { width: 100%; height: 100% }

            body {margin: 0px;}

            #info {display: none;}


            #blocker {

                position: absolute;

                width: 100%;
                height: 100%;

                background-color: rgba(0,0,0,0.5);

            }

            #instructions {

                width: 100%;
                height: 100%;

                display: -webkit-box;
                display: -moz-box;
                display: box;

                -webkit-box-orient: horizontal;
                -moz-box-orient: horizontal;
                box-orient: horizontal;

                -webkit-box-pack: center;
                -moz-box-pack: center;
                box-pack: center;

                -webkit-box-align: center;
                -moz-box-align: center;
                box-align: center;

                color: #ffffff;
                text-align: center;

                cursor: pointer;

            }
        </style>
    </head>
    <body>

        <div id='info'>
            <p id='length'>{{length}}</p>
            <ul id='tweets'>{% for tweet in tweets %}
                <div id="names_and_users">
                    <p id='name'>{{tweet[0]}}</p>
                    <p id='user'>{{tweet[1]}}</p>
                    <p id='time'>{{tweet[2]}}</p>
                </div>
                 {% endfor %}
            </ul>
        </div>

        <div id="blocker">

            <div id="instructions">
                <span style="font-size:40px">Click to play</span>
                <br />
                (W, A, S, D = Move, SPACE = Jump, MOUSE = Look around)
            </div>

        </div>

        <!-- <script src='static/jquery-2.1.1.js' type="text/javascript"></script> -->
        <script src="static/three.js" type="text/javascript"></script>
        <!-- <script src='static/jquery-2.1.1.min.js' type="text/javascript"></script> -->
        <!-- <script src="static/three.min.js" type="text/javascript"></script> -->
        <script src="static/Detector.js" type="text/javascript"></script>
        <script src="static/FirstPersonControls.js" type="text/javascript"></script>
        <script src="static/PointerLockControls.js" type="text/javascript"></script>
        <script src="static/helvetiker_regular.typeface.js" type="text/javascript"></script>
        <script>

            var blocker = document.getElementById( 'blocker' );
            var instructions = document.getElementById( 'instructions' );

            // http://www.html5rocks.com/en/tutorials/pointerlock/intro/

            var havePointerLock = 'pointerLockElement' in document || 'mozPointerLockElement' in document || 'webkitPointerLockElement' in document;

            if ( havePointerLock ) {

                var element = document.body;

                var pointerlockchange = function ( event ) {

                    if ( document.pointerLockElement === element || document.mozPointerLockElement === element || document.webkitPointerLockElement === element ) {

                        controls.enabled = true;

                        blocker.style.display = 'none';

                    } else {

                        controls.enabled = false;

                        blocker.style.display = '-webkit-box';
                        blocker.style.display = '-moz-box';
                        blocker.style.display = 'box';

                        instructions.style.display = '';

                    }

                }

                var pointerlockerror = function ( event ) {

                    instructions.style.display = '';

                }

                // Hook pointer lock state change events
                document.addEventListener( 'pointerlockchange', pointerlockchange, false );
                document.addEventListener( 'mozpointerlockchange', pointerlockchange, false );
                document.addEventListener( 'webkitpointerlockchange', pointerlockchange, false );

                document.addEventListener( 'pointerlockerror', pointerlockerror, false );
                document.addEventListener( 'mozpointerlockerror', pointerlockerror, false );
                document.addEventListener( 'webkitpointerlockerror', pointerlockerror, false );

                instructions.addEventListener( 'click', function ( event ) {

                    instructions.style.display = 'none';

                    // Ask the browser to lock the pointer
                    element.requestPointerLock = element.requestPointerLock || element.mozRequestPointerLock || element.webkitRequestPointerLock;

                    if ( /Firefox/i.test( navigator.userAgent ) ) {

                        var fullscreenchange = function ( event ) {

                            if ( document.fullscreenElement === element || document.mozFullscreenElement === element || document.mozFullScreenElement === element ) {

                                document.removeEventListener( 'fullscreenchange', fullscreenchange );
                                document.removeEventListener( 'mozfullscreenchange', fullscreenchange );

                                element.requestPointerLock();
                            }

                        }

                        document.addEventListener( 'fullscreenchange', fullscreenchange, false );
                        document.addEventListener( 'mozfullscreenchange', fullscreenchange, false );

                        element.requestFullscreen = element.requestFullscreen || element.mozRequestFullscreen || element.mozRequestFullScreen || element.webkitRequestFullscreen;

                        element.requestFullscreen();

                    } else {

                        element.requestPointerLock();

                    }

                }, false );

            } else {

                instructions.innerHTML = 'Your browser doesn\'t seem to support Pointer Lock API';

            }



// DETECT INCOMPATIBLE BROWSERS AND DEVICES
    if ( ! Detector.webgl ) {
        Detector.addGetWebGLMessage();
        document.getElementById( 'container' ).innerHTML = ""; }


// CONSTANTS AND VARIABLE DECLARATIONS
    var PI_2 = Math.PI / 2;
    var NUM_ROWS = 11;
    var BACKGROUND_COLOR = 0xffffff;
    var FOG_COLOR = 0xffffff;
    var ul, user, name, time;


// INIT SCENE, CAMERA, CLOCK AND RENDERER
    var scene = new THREE.Scene();
    var camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 1, 1000);
    var clock = new THREE.Clock();
    var renderer = new THREE.WebGLRenderer({ alpha: true });
    renderer.setClearColor( BACKGROUND_COLOR, 1);
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);


// GET THE INFO FROM THE DOM
    var num_tweets = parseInt(document.getElementById('length').innerHTML);
    var tweetArray = Array( num_tweets );
    for (var i = 0; i < num_tweets; i++) {
        ul = document.getElementById('tweets');
        name = ul.getElementsByTagName('div')[i].childNodes[1].innerHTML;
        user = ul.getElementsByTagName('div')[i].childNodes[3].innerHTML;
        time = ul.getElementsByTagName('div')[i].childNodes[5].innerHTML;
        tweetArray[i] = {name: name, user: user, time: time};
    }


// SET UP THE TERRAIN
    var planeGeometry = new THREE.PlaneGeometry(1000,1000);
    planeGeometry.applyMatrix( new THREE.Matrix4().makeRotationX( -Math.PI / 2 ) );
    var planeMaterial = new THREE.MeshBasicMaterial({ color:0xbeb5b3} );
    var plane = new THREE.Mesh(planeGeometry, planeMaterial);
    plane.castShadow = false;
    plane.receiveShadow = false;
    scene.add( plane );


// ADD GRAVES AND TEXT

    var POSITION_X, POSITION_Z;

    var parameters = {
        size: .5,
        height: .5,
        font: "helvetiker",
        curveSegments: 4,
        style: 'normal',
        weight: 'normal',
        bevelThickness : .05,
        bevelSize : .05,
        bevelEnabled : true, };

    var geometry = new THREE.BoxGeometry( 10, 30, 10);
    var RIPgeometry = new THREE.TextGeometry( '# R I P', parameters );

    for( var i = 0; i < num_tweets; i++ ){

        POSITION_X = i % NUM_ROWS * 30 - 150;
        POSITION_Z = Math.floor(i/NUM_ROWS) * 70;

        tombstone = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: 0x767575 } ) );
        tombstone.position.x = POSITION_X;
        tombstone.position.z = POSITION_Z;
        tombstone.position.y = 10;
        tombstone.castShadow = false;
        tombstone.receiveShadow = false;

        rip_text = new THREE.Mesh(RIPgeometry, new THREE.MeshLambertMaterial( { color: 0xc90400 } ));
        rip_text.position.x = POSITION_X - 3;
        rip_text.position.z = POSITION_Z + 5;
        rip_text.position.y = 20;
        tombstone.castShadow = false;
        tombstone.receiveShadow = false;

        var name_geometry = new THREE.TextGeometry(tweetArray[i].name, parameters);
        name_text = new THREE.Mesh(name_geometry, new THREE.MeshLambertMaterial( { color: 0xc90400 } ));
        name_text.position.x = POSITION_X - 3;
        name_text.position.z = POSITION_Z + 5;
        name_text.position.y = 19;
        name_text.castShadow = false;
        name_text.receiveShadow = false;

        var user_geometry = new THREE.TextGeometry('@' + tweetArray[i].user, parameters);
        user_text = new THREE.Mesh(user_geometry, new THREE.MeshLambertMaterial( { color: 0xc90400 } ));
        user_text.position.x = POSITION_X - 3;
        user_text.position.z = POSITION_Z + 5;
        user_text.position.y = 16;
        user_text.castShadow = false;
        user_text.receiveShadow = false;

        var time_geometry = new THREE.TextGeometry(tweetArray[i].time, parameters);
        time_text = new THREE.Mesh(time_geometry, new THREE.MeshLambertMaterial( { color: 0xc90400 } ));
        time_text.position.x = POSITION_X - 3;
        time_text.position.z = POSITION_Z + 5;
        time_text.position.y = 15;
        time_text.castShadow = false;
        time_text.receiveShadow = false;

        scene.add( tombstone );
        scene.add( rip_text );
        scene.add( user_text );
        scene.add( name_text );
        scene.add( time_text);
    }


// SET THE CAMERA POSITION AND DIRECTION
    camera.setLens(60)
    scene.add( camera );


// CONTROLS
    var controls = new THREE.PointerLockControls( camera );
    scene.add( controls.getObject() );


// LIGHTS
    var light = new THREE.DirectionalLight( 0xffffff, 1 );
    light.position.set(0, -1, .5);
    light.castShadow = true;
    scene.add( light );

// FOG
    // scene.fog = new THREE.FogExp2( FOG_COLOR, 0.03 );


// // MOVING
//     var timer;

//     function move () {
//         if( moveState.front && !moveState.backwards) {
//             camera.position.z += 0.1; }
//         if( moveState.left && !moveState.right) {
//             camera.position.x -= 0.1; }
//         if( !moveState.front && moveState.backwards) {
//             camera.position.z -= 0.1; }
//         if( !moveState.left && moveState.right) {
//             camera.position.x += 0.1; }
//     }

//     var moveState = {
//         moving    : false,
//         front     : false,
//         backwards : false,
//         left      : false,
//         right     : false, }

//     document.addEventListener('keydown', function(e){
//         if( !/65|68|83|87/.test(e.keyCode)){ return }
//         if( e.keyCode === 87 ){
//             moveState.front     = true;
//             moveState.backwards = false;
//         } else if ( e.keyCode === 83 ){
//             moveState.backwards = true;
//             moveState.front     = false;
//         } else if ( e.keyCode === 65 ){
//             moveState.left  = true;
//             moveState.right = false;
//         } else if ( e.keyCode === 68 ){
//             moveState.right = true;
//             moveState.left  = false;
//         }
//         if(!moveState.moving){
//             moveState.moving = true;
//             move();
//             timer = setInterval( function(){
//                 move();
//             }, 1000 / 60);
//         }
//     }, false);

//     document.addEventListener('keyup', function(e){
//         if( !/65|68|83|87/.test(e.keyCode) ) {
//             return }
//         if( e.keyCode === 87 ){
//             moveState.front = false;
//         } else if ( e.keyCode === 83 ){
//             moveState.backwards = false;
//         } else if ( e.keyCode === 65 ){
//             moveState.left = false;
//         } else if ( e.keyCode === 68 ){
//             moveState.right = false;
//         }
//         if(!moveState.front && !moveState.backwards && !moveState.left && !moveState.right){
//             moveState.moving = false;
//             clearInterval(timer);
//         }
//     }, false);


// DEAL WITH WINDOW RESIZING
    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize( window.innerWidth, window.innerHeight );

    }
    window.addEventListener( 'resize', onWindowResize, false );


    function animate(){
        requestAnimationFrame( animate );
        controls.update();
        renderer.render(scene, camera);
    }

    animate();

        </script>
    </body>
</html>
