<!DOCTYPE html>
<html>
<head>
<title>DIGITAL GRAVEYARD</title>
<style>
    canvas { width: 100%; height: 100% }

    body {margin: 0px;}

    #info {display: none;}

</style>
</head>
    <body>

        <div id='info'>
            <p id='length'>{{length}}</p>
            <ul id='tweets'>{% for tweet in tweets %}
                <div id="names_and_users">
                    <p id='name'>{{tweet[0]}}</p>
                    <p id='user'>{{tweet[1]}}</p>
                    <p id='time'>{{tweet[2]}}</p>
                </div>
                 {% endfor %}
            </ul>
        </div>

        <!-- <script src='static/js/jquery-2.1.1.js' type="text/javascript"></script> -->
        <!-- <script src='static/js/jquery-2.1.1.min.js' type="text/javascript"></script> -->
        <!-- <script src="static/js/three.min.js" type="text/javascript"></script> -->
        <script src="static/js/three.js" type="text/javascript"></script>
        <script src="static/js/Detector.js" type="text/javascript"></script>
        <script src="static/js/my_controls.js" type="text/javascript"></script>
        <script src="static/js/helvetiker_regular.typeface.js" type="text/javascript"></script>
        <script src="static/js/loaders/OBJLoader.js" type="text/javascript"></script>


<script type="x-shader/x-vertex" id="vertexShader">

    varying vec3 vWorldPosition;

    void main() {
        vec4 worldPosition = modelMatrix * vec4( position, 1.0 );
        vWorldPosition = worldPosition.xyz;
        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
    }

</script>

<script type="x-shader/x-fragment" id="fragmentShader">

    uniform vec3 topColor;
    uniform vec3 bottomColor;
    uniform float offset;
    uniform float exponent;
    varying vec3 vWorldPosition;

    void main() {
        float h = normalize( vWorldPosition + offset ).y;
        gl_FragColor = vec4( mix( bottomColor, topColor, max( pow( h, exponent ), 0.0 ) ), 1.0 );
    }

</script>


<script>


// DETECT INCOMPATIBLE BROWSERS AND DEVICES
    if ( ! Detector.webgl ) {
        Detector.addGetWebGLMessage();
        document.getElementById( 'container' ).innerHTML = ""; }


// CONSTANTS AND VARIABLE DECLARATIONS
    var PI_2 = Math.PI / 2;
    var NUM_ROWS = 11;
    var BACKGROUND_COLOR = 0xc90400;
    var FOG_COLOR = 0xe7e6e9;
    var ul, user, name, time;
    var date = new Date();
    var utc_offset = date.getTimezoneOffset();
    var candle, item, helper;

    delete date;


// INIT SCENE, CAMERA, CLOCK AND RENDERER
    var scene = new THREE.Scene();
    var camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 1, 8000);
    var clock = new THREE.Clock();
    var renderer = new THREE.WebGLRenderer({ alpha: true });
    renderer.setClearColor( FOG_COLOR, 1);
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);


// MODEL
    var loader = new THREE.OBJLoader();
    loader.load( 'static/models/candle.obj', model_to_scene )

    function model_to_scene ( obj ) {
        obj.scale.set(.1, .1, .1);
        candle = obj;
        scene.add(candle);
    };

// POINTER
    // pointer_geometry = new THREE.BoxGeometry( 5, 5, 5 );
    // pointer_geometry.applyMatrix( new THREE.Matrix4().makeRotationX( -Math.PI / 2 ) );
    // helper = new THREE.Mesh( pointer_geometry, new THREE.MeshBasicMaterial({ color: 0xffffff}) );
    // scene.add( helper );


// SET THE CAMERA POSITION AND DIRECTION
    camera.setLens(60)
    camera.position.setY(10);
    scene.add( camera );


// CONTROLS
    var controls = new MyControls( camera );


// SET UP THE TERRAIN
    var planeGeometry = new THREE.PlaneGeometry(1000,1000);
    planeGeometry.applyMatrix( new THREE.Matrix4().makeRotationX( -Math.PI / 2 ) );
    var planeMaterial = new THREE.MeshBasicMaterial({ color:0xbeb5b3} );
    var plane = new THREE.Mesh(planeGeometry, planeMaterial);
    plane.castShadow = false;
    plane.receiveShadow = false;
    scene.add( plane );


// LIGHTS
    var light = new THREE.DirectionalLight( 0xffffff, 1 );
    light.position.set(0, -1, .5);
    light.castShadow = false;
    scene.add( light );

    var hemiLight = new THREE.HemisphereLight( 0xffffff, 0xffffff, 0.5 );
    hemiLight.color.setHSL( 0.6, 1, 0.75 );
    hemiLight.groundColor.setHSL( 0.1, 0.8, 0.7 );
    hemiLight.position.y = 500;
    scene.add( hemiLight );


// FOG
    scene.fog = new THREE.FogExp2( FOG_COLOR, 0.006 );


// SKYBOX

    var vertexShader = document.getElementById( 'vertexShader' ).textContent;
    var fragmentShader = document.getElementById( 'fragmentShader' ).textContent;
    var uniforms = {
        topColor:    { type: "c", value: new THREE.Color( BACKGROUND_COLOR ) },
        bottomColor: { type: "c", value: new THREE.Color( FOG_COLOR ) },
        offset:      { type: "f", value: 200 },
        exponent:    { type: "f", value: .4 }
    }

    var skyGeo = new THREE.SphereGeometry( 4000, 32, 15 );
    var skyMat = new THREE.ShaderMaterial(
        {   vertexShader: vertexShader,
            fragmentShader: fragmentShader,
            uniforms: uniforms,
            side: THREE.BackSide } );

    var sky = new THREE.Mesh( skyGeo, skyMat );
    scene.add( sky );


// GET THE INFO FROM THE DOM
    var num_tweets = parseInt(document.getElementById('length').innerHTML);
    var tweetArray = Array( num_tweets );
    for (var i = 0; i < num_tweets; i++) {
        ul = document.getElementById('tweets');
        name = ul.getElementsByTagName('div')[i].childNodes[1].innerHTML;
        user = ul.getElementsByTagName('div')[i].childNodes[3].innerHTML;
        time = ul.getElementsByTagName('div')[i].childNodes[5].innerHTML;
        time = adjust_to_users_timezone(time);
        tweetArray[i] = {name: name, user: user, time: time};
    }


// ADD GRAVES AND TEXT

    var POSITION_X, POSITION_Z;

    var parameters = {
        size: .5,
        height: .1,
        font: "helvetiker",
        curveSegments: 4,
        style: 'normal',
        weight: 'normal',
        bevelThickness : .05,
        bevelSize : .05,
        bevelEnabled : true, };

    var geometry = new THREE.BoxGeometry( 10, 30, 10);
    var RIPgeometry = new THREE.TextGeometry( '# R I P', parameters );

    for( var i = 0; i < num_tweets; i++ ){

        POSITION_X = i % NUM_ROWS * 30 - 150;
        POSITION_Z = Math.floor(i/NUM_ROWS) * 50 - Math.floor(num_tweets/NUM_ROWS) * 70;

        tombstone = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: 0x767575 } ) );
        tombstone.position.x = POSITION_X;
        tombstone.position.z = POSITION_Z;
        tombstone.position.y = 10;
        tombstone.castShadow = false;
        tombstone.receiveShadow = false;

        rip_text = new THREE.Mesh(RIPgeometry, new THREE.MeshLambertMaterial( { color: 0xffffff } ));
        rip_text.position.x = POSITION_X - 3;
        rip_text.position.z = POSITION_Z + 5;
        rip_text.position.y = 20;
        tombstone.castShadow = false;
        tombstone.receiveShadow = false;

        var name_geometry = new THREE.TextGeometry(tweetArray[i].name, parameters);
        name_text = new THREE.Mesh(name_geometry, new THREE.MeshLambertMaterial( { color: 0xffffff } ));
        name_text.position.x = POSITION_X - 3;
        name_text.position.z = POSITION_Z + 5;
        name_text.position.y = 19;
        name_text.castShadow = false;
        name_text.receiveShadow = false;

        var user_geometry = new THREE.TextGeometry('@' + tweetArray[i].user, parameters);
        user_text = new THREE.Mesh(user_geometry, new THREE.MeshLambertMaterial( { color: 0xffffff } ));
        user_text.position.x = POSITION_X - 3;
        user_text.position.z = POSITION_Z + 5;
        user_text.position.y = 16;
        user_text.castShadow = false;
        user_text.receiveShadow = false;

        var time_geometry = new THREE.TextGeometry(tweetArray[i].time, parameters);
        time_text = new THREE.Mesh(time_geometry, new THREE.MeshLambertMaterial( { color: 0xffffff } ));
        time_text.position.x = POSITION_X - 3;
        time_text.position.z = POSITION_Z + 5;
        time_text.position.y = 15;
        time_text.castShadow = false;
        time_text.receiveShadow = false;

        scene.add( tombstone );
        scene.add( rip_text );
        scene.add( user_text );
        scene.add( name_text );
        scene.add( time_text);
    }


// ADJUST THE TIME OF THE TWEET TO CLIENT'S LOCAL TIMEZONE
    function adjust_to_users_timezone (time) {
        var new_time = time * 1000 + utc_offset * 60000; // convert to miliseconds, get
        var new_date = new Date(new_time)
        return new_date.toLocaleString()
    }


// DEAL WITH WINDOW RESIZING
    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize( window.innerWidth, window.innerHeight );
        controls.handleResize()

    };


// PLACE THE ITEM
    function placeItem() {
        scene.add( candle.clone() );
    };


    function onMouseMove( event ) {
        var mouseX = ( event.clientX / window.innerWidth ) * 2 - 1;
        var mouseY = -( event.clientY / window.innerHeight ) * 2 + 1;

        var vector = new THREE.Vector3( mouseX, mouseY, camera.near );

        // Convert the [-1, 1] screen coordinate into a world coordinate on the near plane
        var projector = new THREE.Projector();
        projector.unprojectVector( vector, camera );

        var raycaster = new THREE.Raycaster( camera.position, vector.sub( camera.position ).normalize() );

        // See if the ray from the camera into the world hits one of our meshes
        var intersects = raycaster.intersectObject( plane );
        lastIntersects = intersects;

        // Toggle rotation bool for meshes that we clicked
        if ( intersects.length > 0 ) {

            candle.position.copy( intersects[ 0 ].point );
        }
    };



    function animate(){
        requestAnimationFrame( animate );
        controls.update(clock.getDelta());
        renderer.render(scene, camera);
    };


    window.addEventListener( 'resize', onWindowResize, false );
    document.addEventListener( 'mousemove', onMouseMove, false );
    document.addEventListener( 'click', placeItem, false);

    animate();

        </script>
    </body>
</html>
